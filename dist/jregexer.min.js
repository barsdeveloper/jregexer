class e{static escapedCharacter=/([\.\,\|\-\\^\$\(\)\[\]\{\}])/g;static escapeableCharacter=/[adfnrstvwDSW"]/g;static unescapedBackslash=new RegExp(String.raw`(?<=(?:[^\\]|^)(?:\\\\)*)\\(?!\\)`);static insideBracketContent=String.raw`(?:`+String.raw`[^\[\]\\]`+String.raw`|`+String.raw`${e.unescapedBackslash.source}(?:${e.escapedCharacter.source}|${e.escapeableCharacter.source})`+String.raw`)+`;static insideBracket=new RegExp(String.raw`(?<=\[)${e.insideBracketContent}(?=\])`);static anchoredInsideBracket=new RegExp(String.raw`(?<=^\[)${e.insideBracketContent}(?=\]$)`);#e=null;get children(){return this.#e??[]}constructor(...e){this.#e=e}static flattenChildren=e=>e.flatMap((e=>e instanceof this.constructor?this.flattenChildren(e.children):e));parse(e){throw new Error("Not implemented")}createSimplified(){return this}isParenthesized(){return!1}isRegexExhaustive(){return this.children.every((e=>e.isRegexExhaustive()))}regexFragment(e=!1,r=!1,t=!1){return""}}class r extends e{#r=!0;get newline(){return this.#r}constructor(e=!0){super(),this.#r=e}mergeWith(e){return this}regexFragment(e=!1,r=!1,t=!1){return"."}}class t extends e{static singleCharacterRegex=new RegExp(String.raw`^(?:\\${e.escapedCharacter.source}|(?!${e.escapedCharacter.source}).)$`);value="";constructor(e){if(super(),1!==e.length)throw new Error("It must be just a single character");this.value=e}isParenthesized(){return!0}getCharCode(){return this.value.charCodeAt(this.value.length-1)}regexFragment(r=!1,t=!1,n=!1){return this.value.replaceAll(e.escapedCharacter,"\\$0")}}class n extends e{constructor(e,r){if(!(e instanceof t&&r instanceof t))throw new Error("Range values are of unexpected type");if(e.getCharCode()>r.getCharCode())throw new Error("The begin character comes after the end character");super(e,r)}getCharCode(){return this.children[0].getCharCode()}createSimplified(){return this.children[0].getCharCode()===this.children[1].getCharCode()?this.children[0]:this}regexFragment(e=!1,r=!1,t=!1){return this.children[0].regexFragment(!1,!1,!1)+(this.children[1].getCharCode()>this.children[0].getCharCode()+1?"-":"")+this.children[1].regexFragment(!1,!1,!1)}}class i extends e{constructor(...e){if(!e.every((e=>e instanceof t||e instanceof n)))throw new Error("CharacterClass can only have characters or ranges");super(...e)}static mergeRanges(e,r){const[t,i,s,a]=e instanceof n?[e.children[0],e.children[1],e.children[0].getCharCode(),e.children[1].getCharCode()]:[e,e,e.getCharCode(),e.getCharCode()],[h,c,l,o]=r instanceof n?[r.children[0],r.children[1],r.children[0].getCharCode(),r.children[1].getCharCode()]:[r,r,r.getCharCode(),r.getCharCode()];return l<=a+1&&s<=o+1?new n(s<l?t:h,a<o?c:i).createSimplified():null}mergeWith(e){if(e instanceof r)return new r(e.newline);if(e instanceof i)return e.children.reduce(((e,r)=>e.mergeWith(r)),this);if(e instanceof t||e instanceof n){const r=new i(...this.children);return r.children.push(e),r.createSimplified()}return null}isParenthesized(){return!0}createSimplified(){let e=!1,r=[];const n=[...this.children].sort(((e,r)=>e.getCharCode()-r.getCharCode()));let s=n[0];for(let t=1;t<n.length;++t){let a=i.mergeRanges(s,n[t]);a?(s=a,e=!0):(r.push(s),s=n[t])}return r.push(s),1===r.length&&r[0]instanceof t?r[0]:e?new i(...r):this}regexFragment(e=!1,r=!1,t=!1){return"["+this.children.map((e=>e.regexFragment())).join("")+"]"}}class s extends e{value="";constructor(e){super(),this.value=e}createSimplified(){return 1===this.value.length?new t(this.value):this}regexFragment(r=!1,t=!1,n=!1){return this.value.replaceAll(e.escapedCharacter,"\\$1")}}class a extends e{constructor(...e){super(...e)}createSimplified(){let e=new i;const h=[...this.children];let c=new Set,l=!1;for(let o=0;o<h.length;++o){if(h[o]instanceof a){h.splice(o,1,...h[o].children),--o,l=!0;continue}const u=h[o]=h[o].createSimplified();u instanceof r||u instanceof i||u instanceof t||u instanceof n?(e=e.mergeWith(u),h.splice(o,1),--o,l=!0):u instanceof s&&(c.has(u.value)?(h.splice(o,1),--o,l=!0):c.add(u.value))}return e.children.length>0&&(h.push(e.createSimplified()),l=!0),1===h.length?h[0]:l?new a(...h):this}regexFragment(e=!1,r=!1,t=!1){const n=this.children.map(((e,n)=>e.regexFragment(n>0||n<this.children.length-1,r&&0===n,t&&n===this.children.length-1))).reduce(((e,r)=>e+"|"+r));return e?n:"(?:"+n+")"}}class h extends e{#t;constructor(e){super(),this.#t=e}}class c extends e{min=1;max=1;constructor(e,r,t=r){if(super(e),!(r>=0&&r<=t&&r<Number.POSITIVE_INFINITY&&t>0))throw new Error(`Bad min (${r}) or max (${t}) values`);this.min=r,this.max=t}createSimplified(){const e=this.children[0].createSimplified();return e instanceof c?new c(e.children[0],this.min*e.min,this.max*e.max):1===this.min&&this.min===this.max?e:e===this.children[0]?this:new c(e,this.min,this.max)}regexFragment(e=!1,r=!1,t=!1){let n="{"+this.min+","+this.max+"}";if(this.max===Number.POSITIVE_INFINITY)n=0===this.min?"*":1===this.min?"+":`{${this.min},}`;else if(1===this.max){if(0===this.min)n="?";else if(1===this.min)return this.children[0].regexFragment(e,r,t)}else this.max===this.min&&(n=`{${this.min}}`);const i=this.children[0].regexFragment(!0);return(this.children[0].isParenthesized()?i:`(?:${i})`)+n}}class l extends e{constructor(...e){super(...e)}createSimplified(){let e=[...this.children],r=!1;for(let n=0;n<e.length;++n){if(e[n]instanceof l){e.splice(n,1,...e[n].children),--n,r=!0;continue}const i=e[n].createSimplified();if(r||=i!==e[n],e[n]=i,n>0&&(i instanceof s||i instanceof t)){const a=e[n-1];(a instanceof s||a instanceof t)&&(e.splice(n-1,2,new s(a.value+i.value)),--n,r=!0)}}return r?new l(...e):this}regexFragment(e=!1,r=!1,t=!1){let n=this.children.map(((n,i)=>n.regexFragment(e&&1===this.children.length,r&&0===i,t&&i===this.children.length-1))).join("");return e||(n="("+n+")"),n}}class o{#n;get parser(){return this.#n}#i=!1;constructor(e){this.#n=e}static sanitize=r=>{if(r instanceof o)return r;if(r instanceof e)return new o(r);if(r instanceof RegExp)return new o(new h(r));if(r.constructor===String)return 1===r.length?new o(new t(r)):new o(new s(r.valueOf()));throw Error("Type no accepted")};simplify(){return this.#i||(this.#n=this.#n.createSimplified(),this.#i=!0),this}createRegex(e="g"){return this.#i||this.simplify(),new RegExp(this.parser.regexFragment(!0,!0,!0),e)}parse(e){return this.#n.parse(e)}or(e){if(!(e instanceof o))throw new Error('Please use the function R() to create parsers: [...].or(R("b"))');return new o(new a(this.parser,e.parser))}then(e){if(!(e instanceof o))throw new Error('Please use the function R() to create parsers [...].then(R("b"))');return new o(new l(this.parser,e.parser))}sepBy(e,r=0){if(!(e instanceof o))throw new Error('Please use the function R() to create parsers [...].sepBy(R("b"))');return new o(new l(this.parser,new c(new l(e.parser,this.parser),r,Number.POSITIVE_INFINITY)))}sepBy1(e){return this.sepBy(e,1)}times(e,r=e){if(e<0)throw new Error("Must be at least 0, the value provided is negative");if(e>r)throw new Error("Max must be greater than min");return new o(new c(this.parser,e,r))}atLeast(e){return this.times(e,Number.POSITIVE_INFINITY)}atMost(e){return this.times(0,e)}plus(){return this.atLeast(1)}star(){return this.atLeast(0)}maybe(){return this.times(0,1)}map(e){return new h}}const u=o.sanitize;export{u as R};
