class e{status=!1;result;constructor(e){this.result=e}}class t{static escapedCharacter=/([\.\,\|\-\\^\$\(\)\[\]\{\}])/g;static escapeableCharacter=/[adfnrstvwDSW"]/g;static unescapedBackslash=new RegExp(String.raw`(?<=(?:[^\\]|^)(?:\\\\)*)\\(?!\\)`);static insideBracketContent=String.raw`(?:`+String.raw`[^\[\]\\]`+String.raw`|`+String.raw`${t.unescapedBackslash.source}(?:${t.escapedCharacter.source}|${t.escapeableCharacter.source})`+String.raw`)+`;static insideBracket=new RegExp(String.raw`(?<=\[)${t.insideBracketContent}(?=\])`);static anchoredInsideBracket=new RegExp(String.raw`(?<=^\[)${t.insideBracketContent}(?=\]$)`);#e;#t=-1;#r;#i=null;get children(){return this.#i??[]}constructor(...e){this.#i=e}static furthestFailure(e,t){}createFailure(e,t){return{status:!1,value:e,location:t}}createSuccess(e,t){return{status:!0,value:e,remaining:t}}createRegex(e="g"){return this.#e||(this.#e=new RegExp("^"+this.regexFragment(!0,!0,!0),e)),this.#e}parse(t){if(this.isRegexExhaustive()){const r=this.createRegex().exec(t);return r?this.createSuccess(r[0],t.substring(r[0].length)):new e(r)}return this.parseImplement(t)}parseImplement(e){if(1==this.children.length)return this.children[0].parseImplement(e);throw new Error("Not implemented")}createSimplified(){return this}isParenthesized(){return!1}isRegexExhaustive(e=new Set){return null!=this.#r?this.#r:e.has(this)?(this.#r=!1,this.#r):(e.add(this),this.#r=this.children.every((t=>t.isRegexExhaustive(e))),e.delete(this),this.#r)}treeRecursion(e=new Set,t=Number.POSITIVE_INFINITY){if(this.#t>=0)return this.#t;if(e.has(this))return this.#t=1,this.#t;if(e.add(this),--t>=0)for(let r=0;r<this.#i.length;++r){let i;if(i=this.#i[r].treeRecursion(e,t))return this.#t=++i,this.#t}return this.#t=0,this.#t}regexFragment(e=!1,t=!1,r=!1){return""}deepFind(e,t=new Set,r=!0){if(r&&e(this))return this;t.add(this);const i=this.children.find((r=>r.deepFind(e,t)));return t.delete(this),i}}class r extends t{mergeWith(e){return e}}class i extends r{#s=!0;get newline(){return this.#s}constructor(e=!0){super(),this.#s=e}mergeWith(e){return this}regexFragment(e=!1,t=!1,r=!1){return"."}}class s extends r{static singleCharacterRegex=new RegExp(String.raw`^(?:\\${t.escapedCharacter.source}|(?!${t.escapedCharacter.source}).)$`);value="";constructor(e){if(super(),1!==e.length)throw new Error("It must be just a single character");this.value=e}isParenthesized(){return!0}getCharCode(){return this.value.charCodeAt(this.value.length-1)}regexFragment(e=!1,r=!1,i=!1){return this.value.replaceAll(t.escapedCharacter,"\\$0")}}class n extends r{constructor(e,t){if(!(e instanceof s&&t instanceof s))throw new Error("Range values are of unexpected type");if(e.getCharCode()>t.getCharCode())throw new Error("The begin character comes after the end character");super(e,t)}getCharCode(){return this.children[0].getCharCode()}createSimplified(){return this.children[0].getCharCode()===this.children[1].getCharCode()?this.children[0]:this}regexFragment(e=!1,t=!1,r=!1){return this.children[0].regexFragment(!1,!1,!1)+(this.children[1].getCharCode()>this.children[0].getCharCode()+1?"-":"")+this.children[1].regexFragment(!1,!1,!1)}}class a extends r{constructor(...e){if(!e.every((e=>e instanceof s||e instanceof n)))throw new Error("CharacterClass can only have characters or ranges");super(...e)}static mergeRanges(e,t){const[r,i,s,a]=e instanceof n?[e.children[0],e.children[1],e.children[0].getCharCode(),e.children[1].getCharCode()]:[e,e,e.getCharCode(),e.getCharCode()],[h,c,l,u]=t instanceof n?[t.children[0],t.children[1],t.children[0].getCharCode(),t.children[1].getCharCode()]:[t,t,t.getCharCode(),t.getCharCode()];return l<=a+1&&s<=u+1?new n(s<l?r:h,a<u?c:i).createSimplified():null}mergeWith(e){if(e instanceof i)return new i(e.newline);if(e instanceof a)return e.children.reduce(((e,t)=>e.mergeWith(t)),this);if(e instanceof s||e instanceof n){const t=new a(...this.children);return t.children.push(e),t}return null}isParenthesized(){return!0}createSimplified(){let e=!1,t=[];const r=[...this.children].sort(((e,t)=>e.getCharCode()-t.getCharCode()));let i=r[0];for(let s=1;s<r.length;++s){let n=a.mergeRanges(i,r[s]);n?(i=n,e=!0):(t.push(i),i=r[s])}return t.push(i),1===t.length&&t[0]instanceof s?t[0]:e?new a(...t):this}regexFragment(e=!1,t=!1,r=!1){return"["+this.children.map((e=>e.regexFragment())).join("")+"]"}}class h extends t{value="";constructor(e){super(),this.value=e}createSimplified(){return 1===this.value.length?new s(this.value):this}regexFragment(e=!1,r=!1,i=!1){return this.value.replaceAll(t.escapedCharacter,"\\$1")}}class c extends t{constructor(...e){super(...e)}createSimplified(){let e=new a;const t=[...this.children];let r=new Set,l=!1;for(let u=0;u<t.length;++u){if(t[u]instanceof c){t.splice(u,1,...t[u].children),--u,l=!0;continue}const o=t[u]=t[u].createSimplified();o instanceof i||o instanceof a||o instanceof s||o instanceof n?(e=e.mergeWith(o),t.splice(u,1),--u,l=!0):o instanceof h&&(r.has(o.value)?(t.splice(u,1),--u,l=!0):r.add(o.value))}return e.children.length>0&&(t.push(e.createSimplified()),l=!0),1===t.length?t[0]:l?new c(...t):this}regexFragment(e=!1,t=!1,r=!1){const i=this.children.map(((e,i)=>e.regexFragment(i>0||i<this.children.length-1,t&&0===i,r&&i===this.children.length-1))).reduce(((e,t)=>e+"|"+t));return e?i:"(?:"+i+")"}parseImplement(e){for(let t of this.children){const r=t.parse(e);if(r.status)return r}return this.createFailure(e)}}class l extends t{#e;constructor(e){super(),this.#e=e}}class u extends t{constructor(e){super(e)}isParenthesized(){return!0}regexFragment(e=!1,t=!1,r=!1){return"("+this.children[0].regexFragment(!0,t,r)+")"}}class o extends t{min=1;max=1;constructor(e,t,r=t){if(super(e),!(t>=0&&t<=r&&t<Number.POSITIVE_INFINITY&&r>0))throw new Error(`Bad min (${t}) or max (${r}) values`);this.min=t,this.max=r}createSimplified(){const e=this.children[0].createSimplified();return e instanceof o?new o(e.children[0],this.min*e.min,this.max*e.max):1===this.min&&this.min===this.max?e:e===this.children[0]?this:new o(e,this.min,this.max)}regexFragment(e=!1,t=!1,r=!1){let i="{"+this.min+","+this.max+"}";if(this.max===Number.POSITIVE_INFINITY)i=0===this.min?"*":1===this.min?"+":`{${this.min},}`;else if(1===this.max){if(0===this.min)i="?";else if(1===this.min)return this.children[0].regexFragment(e,t,r)}else this.max===this.min&&(i=`{${this.min}}`);const s=this.children[0].regexFragment(!0);return(this.children[0].isParenthesized()?s:`(?:${s})`)+i}isRegexExhaustive(e=new Set){if(this.max<=1)return super.isRegexExhaustive(e);if(e.has(this))return!1;return null==this.deepFind((t=>!t.isRegexExhaustive(e)||t instanceof u),e)}}class d extends t{constructor(...e){super(...e)}createSimplified(){let e=[...this.children],t=!1;for(let r=0;r<e.length;++r){if(e[r]instanceof d){e.splice(r,1,...e[r].children),--r,t=!0;continue}const i=e[r].createSimplified();if(t||=i!==e[r],e[r]=i,r>0&&(i instanceof h||i instanceof s)){const n=e[r-1];(n instanceof h||n instanceof s)&&(e.splice(r-1,2,new h(n.value+i.value)),--r,t=!0)}}return t?new d(...e):this}regexFragment(e=!1,t=!1,r=!1){let i=this.children.map(((i,s)=>i.regexFragment(e&&1===this.children.length,t&&0===s,r&&s===this.children.length-1))).join("");return e||(i="("+i+")"),i}}class g{#n;get parser(){return this.#n}#a=!1;constructor(e){this.#n=e}static sanitize=e=>{if(e instanceof g)return e;if(e instanceof t)return new g(e);if(e instanceof RegExp)return new g(new l(e));if(e.constructor===String)return 1===e.length?new g(new s(e)):new g(new h(e.valueOf()));throw Error("Type no accepted")};simplify(){return this.#a||(this.#n=this.#n.createSimplified(),this.#a=!0),this}createRegex(e="g"){return this.#a||this.simplify(),new RegExp(this.parser.regexFragment(!0,!0,!0),e)}parse(e){return this.#n.parse(e)}or(e){if(!(e instanceof g))throw new Error('Please use the function R() to create parsers: [...].or(R("b"))');return new g(new c(this.parser,e.parser))}then(e){if(!(e instanceof g))throw new Error('Please use the function R() to create parsers [...].then(R("b"))');return new g(new d(this.parser,e.parser))}sepBy(e,t=0){if(!(e instanceof g))throw new Error('Please use the function R() to create parsers [...].sepBy(R("b"))');return new g(new d(this.parser,new o(new d(e.parser,this.parser),t,Number.POSITIVE_INFINITY)))}sepBy1(e){return this.sepBy(e,1)}times(e,t=e){if(e<0)throw new Error("Must be at least 0, the value provided is negative");if(e>t)throw new Error("Max must be greater than min");return new g(new o(this.parser,e,t))}atLeast(e){return this.times(e,Number.POSITIVE_INFINITY)}atMost(e){return this.times(0,e)}plus(){return this.atLeast(1)}star(){return this.atLeast(0)}maybe(){return this.times(0,1)}map(e){return new l}}const p=g.sanitize;export{p as R};
